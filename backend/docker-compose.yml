version: '3.8'

services:
  # Base de datos PostgreSQL
  postgres:
    image: postgres:15-alpine
    container_name: rsc-postgres
    environment:
      POSTGRES_DB: rsc_mining
      POSTGRES_USER: rsc_user
      POSTGRES_PASSWORD: rsc_password_2024
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./migrations:/docker-entrypoint-initdb.d
    networks:
      - rsc-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U rsc_user -d rsc_mining"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Backend de minería RSC
  rsc-backend:
    build: .
    container_name: rsc-backend
    environment:
      # Base de datos
      DATABASE_URL: postgres://rsc_user:rsc_password_2024@postgres:5432/rsc_mining
      
      # Autenticación
      JWT_SECRET: rsc_jwt_secret_key_2024_production
      JWT_EXPIRES: 7d
      ADMIN_JWT_SECRET: rsc_admin_jwt_secret_key_2024_production
      ADMIN_JWT_EXPIRES: 7d
      
      # Seguridad
      RATE_LIMIT_WINDOW_MS: 60000
      RATE_LIMIT_MAX: 120
      CORS_ORIGIN: "*"
      
      # Minería
      MINE_COOLDOWN_SECONDS: 60
      MINE_REWARD_MIN: 0.001
      MINE_REWARD_MAX: 0.05
      MINE_DAILY_CAP: 5
      
      # Caché
      CACHE_TTL_SECONDS: 30
      
      # App
      PORT: 4000
      NODE_ENV: production
      
      # RSC Chain API
      RSC_CHAIN_API: https://rsc-chain-production.up.railway.app/
    ports:
      - "4000:4000"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - rsc-network
    restart: unless-stopped
    volumes:
      - ./logs:/app/logs
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:4000/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Redis para caché (opcional, reemplaza NodeCache)
  redis:
    image: redis:7-alpine
    container_name: rsc-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - rsc-network
    restart: unless-stopped
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # Nginx como proxy reverso (opcional)
  nginx:
    image: nginx:alpine
    container_name: rsc-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - rsc-backend
    networks:
      - rsc-network
    restart: unless-stopped
    profiles:
      - production

  # pgAdmin para gestión de base de datos (solo desarrollo)
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: rsc-pgadmin
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@rsc.local
      PGADMIN_DEFAULT_PASSWORD: admin123
      PGADMIN_CONFIG_SERVER_MODE: 'False'
    ports:
      - "5050:80"
    depends_on:
      - postgres
    networks:
      - rsc-network
    restart: unless-stopped
    profiles:
      - development

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local

networks:
  rsc-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

# Configuración de recursos
x-resource-limits: &resource-limits
  deploy:
    resources:
      limits:
        memory: 512M
        cpus: '0.5'
      reservations:
        memory: 256M
        cpus: '0.25'

# Aplicar límites de recursos
services:
  postgres:
    <<: *resource-limits
  rsc-backend:
    <<: *resource-limits
  redis:
    <<: *resource-limits
